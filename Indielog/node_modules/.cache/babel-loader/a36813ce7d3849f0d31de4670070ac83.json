{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/position\n */\nimport global from './global';\nimport Rect from './rect';\nimport getPositionedAncestor from './getpositionedancestor';\nimport getBorderWidths from './getborderwidths';\nimport { isFunction } from 'lodash-es';\n/**\n * Calculates the `position: absolute` coordinates of a given element so it can be positioned with respect to the\n * target in the visually most efficient way, taking various restrictions like viewport or limiter geometry\n * into consideration.\n *\n *\t\t// The element which is to be positioned.\n *\t\tconst element = document.body.querySelector( '#toolbar' );\n *\n *\t\t// A target to which the element is positioned relatively.\n *\t\tconst target = document.body.querySelector( '#container' );\n *\n *\t\t// Finding the optimal coordinates for the positioning.\n *\t\tconst { left, top, name } = getOptimalPosition( {\n *\t\t\telement: element,\n *\t\t\ttarget: target,\n *\n * \t\t\t// The algorithm will chose among these positions to meet the requirements such\n * \t\t\t// as \"limiter\" element or \"fitInViewport\", set below. The positions are considered\n * \t\t\t// in the order of the array.\n *\t\t\tpositions: [\n *\t\t\t\t//\n *\t\t\t \t//\t[ Target ]\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t|     Element     |\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\n *\t\t\t\ttargetRect => ( {\n *\t\t\t\t\ttop: targetRect.bottom,\n *\t\t\t\t\tleft: targetRect.left,\n *\t\t\t\t\tname: 'mySouthEastPosition'\n *\t\t\t\t} ),\n *\n *\t\t\t\t//\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t|     Element     |\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t[ Target ]\n *\t\t\t\t//\n *\t\t\t\t( targetRect, elementRect ) => ( {\n *\t\t\t\t\ttop: targetRect.top - elementRect.height,\n *\t\t\t\t\tleft: targetRect.left,\n *\t\t\t\t\tname: 'myNorthEastPosition'\n *\t\t\t\t} )\n *\t\t\t],\n *\n *\t\t\t// Find a position such guarantees the element remains within visible boundaries of <body>.\n *\t\t\tlimiter: document.body,\n *\n *\t\t\t// Find a position such guarantees the element remains within visible boundaries of the browser viewport.\n *\t\t\tfitInViewport: true\n *\t\t} );\n *\n *\t\t// The best position which fits into document.body and the viewport. May be useful\n *\t\t// to set proper class on the `element`.\n *\t\tconsole.log( name ); // -> \"myNorthEastPosition\"\n *\n *\t\t// Using the absolute coordinates which has been found to position the element\n *\t\t// as in the diagram depicting the \"myNorthEastPosition\" position.\n *\t\telement.style.top = top;\n *\t\telement.style.left = left;\n *\n * @param {module:utils/dom/position~Options} options Positioning options object.\n * @returns {module:utils/dom/position~Position}\n */\n\nexport function getOptimalPosition({\n  element,\n  target,\n  positions,\n  limiter,\n  fitInViewport\n}) {\n  // If the {@link module:utils/dom/position~Options#target} is a function, use what it returns.\n  // https://github.com/ckeditor/ckeditor5-utils/issues/157\n  if (isFunction(target)) {\n    target = target();\n  } // If the {@link module:utils/dom/position~Options#limiter} is a function, use what it returns.\n  // https://github.com/ckeditor/ckeditor5-ui/issues/260\n\n\n  if (isFunction(limiter)) {\n    limiter = limiter();\n  }\n\n  const positionedElementAncestor = getPositionedAncestor(element);\n  const elementRect = new Rect(element);\n  const targetRect = new Rect(target);\n  let bestPositionRect;\n  let bestPositionName; // If there are no limits, just grab the very first position and be done with that drama.\n\n  if (!limiter && !fitInViewport) {\n    [bestPositionName, bestPositionRect] = getPositionNameAndRect(positions[0], targetRect, elementRect);\n  } else {\n    const limiterRect = limiter && new Rect(limiter).getVisible();\n    const viewportRect = fitInViewport && new Rect(global.window);\n    const bestPosition = getBestPositionNameAndRect(positions, {\n      targetRect,\n      elementRect,\n      limiterRect,\n      viewportRect\n    }); // If there's no best position found, i.e. when all intersections have no area because\n    // rects have no width or height, then just use the first available position.\n\n    [bestPositionName, bestPositionRect] = bestPosition || getPositionNameAndRect(positions[0], targetRect, elementRect);\n  }\n\n  let absoluteRectCoordinates = getAbsoluteRectCoordinates(bestPositionRect);\n\n  if (positionedElementAncestor) {\n    absoluteRectCoordinates = shiftRectCoordinatesDueToPositionedAncestor(absoluteRectCoordinates, positionedElementAncestor);\n  }\n\n  return {\n    left: absoluteRectCoordinates.left,\n    top: absoluteRectCoordinates.top,\n    name: bestPositionName\n  };\n} // For given position function, returns a corresponding `Rect` instance.\n//\n// @private\n// @param {Function} position A function returning {@link module:utils/dom/position~Position}.\n// @param {utils/dom/rect~Rect} targetRect A rect of the target.\n// @param {utils/dom/rect~Rect} elementRect A rect of positioned element.\n// @returns {Array|null} An array containing position name and its Rect (or null if position should be ignored).\n\nfunction getPositionNameAndRect(position, targetRect, elementRect) {\n  const positionData = position(targetRect, elementRect);\n\n  if (!positionData) {\n    return null;\n  }\n\n  const {\n    left,\n    top,\n    name\n  } = positionData;\n  return [name, elementRect.clone().moveTo(left, top)];\n} // For a given array of positioning functions, returns such that provides the best\n// fit of the `elementRect` into the `limiterRect` and `viewportRect`.\n//\n// @private\n//\n// @param {Object} options\n// @param {module:utils/dom/position~Options#positions} positions Functions returning {@link module:utils/dom/position~Position}\n// to be checked, in the order of preference.\n// @param {Object} options\n// @param {utils/dom/rect~Rect} options.targetRect A rect of the {@link module:utils/dom/position~Options#target}.\n// @param {utils/dom/rect~Rect} options.elementRect A rect of positioned {@link module:utils/dom/position~Options#element}.\n// @param {utils/dom/rect~Rect} options.limiterRect A rect of the {@link module:utils/dom/position~Options#limiter}.\n// @param {utils/dom/rect~Rect} options.viewportRect A rect of the viewport.\n//\n// @returns {Array} An array containing the name of the position and it's rect.\n\n\nfunction getBestPositionNameAndRect(positions, options) {\n  const {\n    elementRect,\n    viewportRect\n  } = options; // This is when element is fully visible.\n\n  const elementRectArea = elementRect.getArea(); // Let's calculate intersection areas for positions. It will end early if best match is found.\n\n  const processedPositions = processPositionsToAreas(positions, options); // First let's check all positions that fully fit in the viewport.\n\n  if (viewportRect) {\n    const processedPositionsInViewport = processedPositions.filter(({\n      viewportIntersectArea\n    }) => {\n      return viewportIntersectArea === elementRectArea;\n    }); // Try to find best position from those which fit completely in viewport.\n\n    const bestPositionData = getBestOfProcessedPositions(processedPositionsInViewport, elementRectArea);\n\n    if (bestPositionData) {\n      return bestPositionData;\n    }\n  } // Either there is no viewportRect or there is no position that fits completely in the viewport.\n\n\n  return getBestOfProcessedPositions(processedPositions, elementRectArea);\n} // For a given array of positioning functions, calculates intersection areas for them.\n//\n// Note: If some position fully fits into the `limiterRect`, it will be returned early, without further consideration\n// of other positions.\n//\n// @private\n//\n// @param {module:utils/dom/position~Options#positions} positions Functions returning {@link module:utils/dom/position~Position}\n// to be checked, in the order of preference.\n// @param {Object} options\n// @param {utils/dom/rect~Rect} options.targetRect A rect of the {@link module:utils/dom/position~Options#target}.\n// @param {utils/dom/rect~Rect} options.elementRect A rect of positioned {@link module:utils/dom/position~Options#element}.\n// @param {utils/dom/rect~Rect} options.limiterRect A rect of the {@link module:utils/dom/position~Options#limiter}.\n// @param {utils/dom/rect~Rect} options.viewportRect A rect of the viewport.\n//\n// @returns {Array.<Object>} Array of positions with calculated intersection areas. Each item is an object containing:\n// * {String} positionName Name of position.\n// * {utils/dom/rect~Rect} positionRect Rect of position.\n// * {Number} limiterIntersectArea Area of intersection of the position with limiter part that is in the viewport.\n// * {Number} viewportIntersectArea Area of intersection of the position with viewport.\n\n\nfunction processPositionsToAreas(positions, {\n  targetRect,\n  elementRect,\n  limiterRect,\n  viewportRect\n}) {\n  const processedPositions = []; // This is when element is fully visible.\n\n  const elementRectArea = elementRect.getArea();\n\n  for (const position of positions) {\n    const positionData = getPositionNameAndRect(position, targetRect, elementRect);\n\n    if (!positionData) {\n      continue;\n    }\n\n    const [positionName, positionRect] = positionData;\n    let limiterIntersectArea = 0;\n    let viewportIntersectArea = 0;\n\n    if (limiterRect) {\n      if (viewportRect) {\n        // Consider only the part of the limiter which is visible in the viewport. So the limiter is getting limited.\n        const limiterViewportIntersectRect = limiterRect.getIntersection(viewportRect);\n\n        if (limiterViewportIntersectRect) {\n          // If the limiter is within the viewport, then check the intersection between that part of the\n          // limiter and actual position.\n          limiterIntersectArea = limiterViewportIntersectRect.getIntersectionArea(positionRect);\n        }\n      } else {\n        limiterIntersectArea = limiterRect.getIntersectionArea(positionRect);\n      }\n    }\n\n    if (viewportRect) {\n      viewportIntersectArea = viewportRect.getIntersectionArea(positionRect);\n    }\n\n    const processedPosition = {\n      positionName,\n      positionRect,\n      limiterIntersectArea,\n      viewportIntersectArea\n    }; // If a such position is found that element is fully contained by the limiter then, obviously,\n    // there will be no better one, so finishing.\n\n    if (limiterIntersectArea === elementRectArea) {\n      return [processedPosition];\n    }\n\n    processedPositions.push(processedPosition);\n  }\n\n  return processedPositions;\n} // For a given array of processed position data (with calculated Rects for positions and intersection areas)\n// returns such that provides the best fit of the `elementRect` into the `limiterRect` and `viewportRect` at the same time.\n//\n// **Note**: It will return early if some position fully fits into the `limiterRect`.\n//\n// @private\n// @param {Array.<Object>} Array of positions with calculated intersection areas (in order of preference).\n// Each item is an object containing:\n//\n//\t* {String} positionName Name of position.\n//\t* {utils/dom/rect~Rect} positionRect Rect of position.\n//\t* {Number} limiterIntersectArea Area of intersection of the position with limiter part that is in the viewport.\n//\t* {Number} viewportIntersectArea Area of intersection of the position with viewport.\n//\n// @param {Number} elementRectArea Area of positioned {@link module:utils/dom/position~Options#element}.\n// @returns {Array|null} An array containing the name of the position and it's rect, or null if not found.\n\n\nfunction getBestOfProcessedPositions(processedPositions, elementRectArea) {\n  let maxFitFactor = 0;\n  let bestPositionRect;\n  let bestPositionName;\n\n  for (const {\n    positionName,\n    positionRect,\n    limiterIntersectArea,\n    viewportIntersectArea\n  } of processedPositions) {\n    // If a such position is found that element is fully container by the limiter then, obviously,\n    // there will be no better one, so finishing.\n    if (limiterIntersectArea === elementRectArea) {\n      return [positionName, positionRect];\n    } // To maximize both viewport and limiter intersection areas we use distance on viewportIntersectArea\n    // and limiterIntersectArea plane (without sqrt because we are looking for max value).\n\n\n    const fitFactor = viewportIntersectArea ** 2 + limiterIntersectArea ** 2;\n\n    if (fitFactor > maxFitFactor) {\n      maxFitFactor = fitFactor;\n      bestPositionRect = positionRect;\n      bestPositionName = positionName;\n    }\n  }\n\n  return bestPositionRect ? [bestPositionName, bestPositionRect] : null;\n} // For a given absolute Rect coordinates object and a positioned element ancestor, it returns an object with\n// new Rect coordinates that make up for the position and the scroll of the ancestor.\n//\n// This is necessary because while Rects (and DOMRects) are relative to the browser's viewport, their coordinates\n// are used in real–life to position elements with `position: absolute`, which are scoped by any positioned\n// (and scrollable) ancestors.\n//\n// @private\n//\n// @param {Object} absoluteRectCoordinates An object with absolute rect coordinates.\n// @param {Object} absoluteRectCoordinates.top\n// @param {Object} absoluteRectCoordinates.left\n// @param {HTMLElement} positionedElementAncestor An ancestor element that should be considered.\n//\n// @returns {Object} An object corresponding to `absoluteRectCoordinates` input but with values shifted\n// to make up for the positioned element ancestor.\n\n\nfunction shiftRectCoordinatesDueToPositionedAncestor({\n  left,\n  top\n}, positionedElementAncestor) {\n  const ancestorPosition = getAbsoluteRectCoordinates(new Rect(positionedElementAncestor));\n  const ancestorBorderWidths = getBorderWidths(positionedElementAncestor); // (https://github.com/ckeditor/ckeditor5-ui-default/issues/126)\n  // If there's some positioned ancestor of the panel, then its `Rect` must be taken into\n  // consideration. `Rect` is always relative to the viewport while `position: absolute` works\n  // with respect to that positioned ancestor.\n\n  left -= ancestorPosition.left;\n  top -= ancestorPosition.top; // (https://github.com/ckeditor/ckeditor5-utils/issues/139)\n  // If there's some positioned ancestor of the panel, not only its position must be taken into\n  // consideration (see above) but also its internal scrolls. Scroll have an impact here because `Rect`\n  // is relative to the viewport (it doesn't care about scrolling), while `position: absolute`\n  // must compensate that scrolling.\n\n  left += positionedElementAncestor.scrollLeft;\n  top += positionedElementAncestor.scrollTop; // (https://github.com/ckeditor/ckeditor5-utils/issues/139)\n  // If there's some positioned ancestor of the panel, then its `Rect` includes its CSS `borderWidth`\n  // while `position: absolute` positioning does not consider it.\n  // E.g. `{ position: absolute, top: 0, left: 0 }` means upper left corner of the element,\n  // not upper-left corner of its border.\n\n  left -= ancestorBorderWidths.left;\n  top -= ancestorBorderWidths.top;\n  return {\n    left,\n    top\n  };\n} // DOMRect (also Rect) works in a scroll–independent geometry but `position: absolute` doesn't.\n// This function converts Rect to `position: absolute` coordinates.\n//\n// @private\n// @param {utils/dom/rect~Rect} rect A rect to be converted.\n// @returns {Object} Object containing `left` and `top` properties, in absolute coordinates.\n\n\nfunction getAbsoluteRectCoordinates({\n  left,\n  top\n}) {\n  const {\n    scrollX,\n    scrollY\n  } = global.window;\n  return {\n    left: left + scrollX,\n    top: top + scrollY\n  };\n}\n/**\n * The `getOptimalPosition()` helper options.\n *\n * @interface module:utils/dom/position~Options\n */\n\n/**\n * Element that is to be positioned.\n *\n * @member {HTMLElement} #element\n */\n\n/**\n * Target with respect to which the `element` is to be positioned.\n *\n * @member {HTMLElement|Range|Window|ClientRect|DOMRect|module:utils/dom/rect~Rect|Object|Function} #target\n */\n\n/**\n * An array of functions which return {@link module:utils/dom/position~Position} relative\n * to the `target`, in the order of preference.\n *\n * **Note**: If a function returns `null`, it is ignored by the `getOptimalPosition()`.\n *\n * @member {Array.<Function>} #positions\n */\n\n/**\n * When set, the algorithm will chose position which fits the most in the\n * limiter's bounding rect.\n *\n * @member {HTMLElement|Range|Window|ClientRect|DOMRect|module:utils/dom/rect~Rect|Object|Function} #limiter\n */\n\n/**\n * When set, the algorithm will chose such a position which fits `element`\n * the most inside visible viewport.\n *\n * @member {Boolean} #fitInViewport\n */\n\n/**\n * An object describing a position in `position: absolute` coordinate\n * system, along with position name.\n *\n * @typedef {Object} module:utils/dom/position~Position\n *\n * @property {Number} top Top position offset.\n * @property {Number} left Left position offset.\n * @property {String} name Name of the position.\n */","map":{"version":3,"sources":["/Users/fanyukun/Documents/react/indielog/node_modules/@ckeditor/ckeditor5-utils/src/dom/position.js"],"names":["global","Rect","getPositionedAncestor","getBorderWidths","isFunction","getOptimalPosition","element","target","positions","limiter","fitInViewport","positionedElementAncestor","elementRect","targetRect","bestPositionRect","bestPositionName","getPositionNameAndRect","limiterRect","getVisible","viewportRect","window","bestPosition","getBestPositionNameAndRect","absoluteRectCoordinates","getAbsoluteRectCoordinates","shiftRectCoordinatesDueToPositionedAncestor","left","top","name","position","positionData","clone","moveTo","options","elementRectArea","getArea","processedPositions","processPositionsToAreas","processedPositionsInViewport","filter","viewportIntersectArea","bestPositionData","getBestOfProcessedPositions","positionName","positionRect","limiterIntersectArea","limiterViewportIntersectRect","getIntersection","getIntersectionArea","processedPosition","push","maxFitFactor","fitFactor","ancestorPosition","ancestorBorderWidths","scrollLeft","scrollTop","scrollX","scrollY"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/position\n */\n\nimport global from './global';\nimport Rect from './rect';\nimport getPositionedAncestor from './getpositionedancestor';\nimport getBorderWidths from './getborderwidths';\nimport { isFunction } from 'lodash-es';\n\n/**\n * Calculates the `position: absolute` coordinates of a given element so it can be positioned with respect to the\n * target in the visually most efficient way, taking various restrictions like viewport or limiter geometry\n * into consideration.\n *\n *\t\t// The element which is to be positioned.\n *\t\tconst element = document.body.querySelector( '#toolbar' );\n *\n *\t\t// A target to which the element is positioned relatively.\n *\t\tconst target = document.body.querySelector( '#container' );\n *\n *\t\t// Finding the optimal coordinates for the positioning.\n *\t\tconst { left, top, name } = getOptimalPosition( {\n *\t\t\telement: element,\n *\t\t\ttarget: target,\n *\n * \t\t\t// The algorithm will chose among these positions to meet the requirements such\n * \t\t\t// as \"limiter\" element or \"fitInViewport\", set below. The positions are considered\n * \t\t\t// in the order of the array.\n *\t\t\tpositions: [\n *\t\t\t\t//\n *\t\t\t \t//\t[ Target ]\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t|     Element     |\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\n *\t\t\t\ttargetRect => ( {\n *\t\t\t\t\ttop: targetRect.bottom,\n *\t\t\t\t\tleft: targetRect.left,\n *\t\t\t\t\tname: 'mySouthEastPosition'\n *\t\t\t\t} ),\n *\n *\t\t\t\t//\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t|     Element     |\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t[ Target ]\n *\t\t\t\t//\n *\t\t\t\t( targetRect, elementRect ) => ( {\n *\t\t\t\t\ttop: targetRect.top - elementRect.height,\n *\t\t\t\t\tleft: targetRect.left,\n *\t\t\t\t\tname: 'myNorthEastPosition'\n *\t\t\t\t} )\n *\t\t\t],\n *\n *\t\t\t// Find a position such guarantees the element remains within visible boundaries of <body>.\n *\t\t\tlimiter: document.body,\n *\n *\t\t\t// Find a position such guarantees the element remains within visible boundaries of the browser viewport.\n *\t\t\tfitInViewport: true\n *\t\t} );\n *\n *\t\t// The best position which fits into document.body and the viewport. May be useful\n *\t\t// to set proper class on the `element`.\n *\t\tconsole.log( name ); // -> \"myNorthEastPosition\"\n *\n *\t\t// Using the absolute coordinates which has been found to position the element\n *\t\t// as in the diagram depicting the \"myNorthEastPosition\" position.\n *\t\telement.style.top = top;\n *\t\telement.style.left = left;\n *\n * @param {module:utils/dom/position~Options} options Positioning options object.\n * @returns {module:utils/dom/position~Position}\n */\nexport function getOptimalPosition( { element, target, positions, limiter, fitInViewport } ) {\n\t// If the {@link module:utils/dom/position~Options#target} is a function, use what it returns.\n\t// https://github.com/ckeditor/ckeditor5-utils/issues/157\n\tif ( isFunction( target ) ) {\n\t\ttarget = target();\n\t}\n\n\t// If the {@link module:utils/dom/position~Options#limiter} is a function, use what it returns.\n\t// https://github.com/ckeditor/ckeditor5-ui/issues/260\n\tif ( isFunction( limiter ) ) {\n\t\tlimiter = limiter();\n\t}\n\n\tconst positionedElementAncestor = getPositionedAncestor( element );\n\tconst elementRect = new Rect( element );\n\tconst targetRect = new Rect( target );\n\n\tlet bestPositionRect;\n\tlet bestPositionName;\n\n\t// If there are no limits, just grab the very first position and be done with that drama.\n\tif ( !limiter && !fitInViewport ) {\n\t\t[ bestPositionName, bestPositionRect ] = getPositionNameAndRect( positions[ 0 ], targetRect, elementRect );\n\t} else {\n\t\tconst limiterRect = limiter && new Rect( limiter ).getVisible();\n\t\tconst viewportRect = fitInViewport && new Rect( global.window );\n\t\tconst bestPosition = getBestPositionNameAndRect( positions, { targetRect, elementRect, limiterRect, viewportRect } );\n\n\t\t// If there's no best position found, i.e. when all intersections have no area because\n\t\t// rects have no width or height, then just use the first available position.\n\t\t[ bestPositionName, bestPositionRect ] = bestPosition || getPositionNameAndRect( positions[ 0 ], targetRect, elementRect );\n\t}\n\n\tlet absoluteRectCoordinates = getAbsoluteRectCoordinates( bestPositionRect );\n\n\tif ( positionedElementAncestor ) {\n\t\tabsoluteRectCoordinates = shiftRectCoordinatesDueToPositionedAncestor( absoluteRectCoordinates, positionedElementAncestor );\n\t}\n\n\treturn {\n\t\tleft: absoluteRectCoordinates.left,\n\t\ttop: absoluteRectCoordinates.top,\n\t\tname: bestPositionName\n\t};\n}\n\n// For given position function, returns a corresponding `Rect` instance.\n//\n// @private\n// @param {Function} position A function returning {@link module:utils/dom/position~Position}.\n// @param {utils/dom/rect~Rect} targetRect A rect of the target.\n// @param {utils/dom/rect~Rect} elementRect A rect of positioned element.\n// @returns {Array|null} An array containing position name and its Rect (or null if position should be ignored).\nfunction getPositionNameAndRect( position, targetRect, elementRect ) {\n\tconst positionData = position( targetRect, elementRect );\n\n\tif ( !positionData ) {\n\t\treturn null;\n\t}\n\n\tconst { left, top, name } = positionData;\n\n\treturn [ name, elementRect.clone().moveTo( left, top ) ];\n}\n\n// For a given array of positioning functions, returns such that provides the best\n// fit of the `elementRect` into the `limiterRect` and `viewportRect`.\n//\n// @private\n//\n// @param {Object} options\n// @param {module:utils/dom/position~Options#positions} positions Functions returning {@link module:utils/dom/position~Position}\n// to be checked, in the order of preference.\n// @param {Object} options\n// @param {utils/dom/rect~Rect} options.targetRect A rect of the {@link module:utils/dom/position~Options#target}.\n// @param {utils/dom/rect~Rect} options.elementRect A rect of positioned {@link module:utils/dom/position~Options#element}.\n// @param {utils/dom/rect~Rect} options.limiterRect A rect of the {@link module:utils/dom/position~Options#limiter}.\n// @param {utils/dom/rect~Rect} options.viewportRect A rect of the viewport.\n//\n// @returns {Array} An array containing the name of the position and it's rect.\nfunction getBestPositionNameAndRect( positions, options ) {\n\tconst { elementRect, viewportRect } = options;\n\n\t// This is when element is fully visible.\n\tconst elementRectArea = elementRect.getArea();\n\n\t// Let's calculate intersection areas for positions. It will end early if best match is found.\n\tconst processedPositions = processPositionsToAreas( positions, options );\n\n\t// First let's check all positions that fully fit in the viewport.\n\tif ( viewportRect ) {\n\t\tconst processedPositionsInViewport = processedPositions.filter( ( { viewportIntersectArea } ) => {\n\t\t\treturn viewportIntersectArea === elementRectArea;\n\t\t} );\n\n\t\t// Try to find best position from those which fit completely in viewport.\n\t\tconst bestPositionData = getBestOfProcessedPositions( processedPositionsInViewport, elementRectArea );\n\n\t\tif ( bestPositionData ) {\n\t\t\treturn bestPositionData;\n\t\t}\n\t}\n\n\t// Either there is no viewportRect or there is no position that fits completely in the viewport.\n\treturn getBestOfProcessedPositions( processedPositions, elementRectArea );\n}\n\n// For a given array of positioning functions, calculates intersection areas for them.\n//\n// Note: If some position fully fits into the `limiterRect`, it will be returned early, without further consideration\n// of other positions.\n//\n// @private\n//\n// @param {module:utils/dom/position~Options#positions} positions Functions returning {@link module:utils/dom/position~Position}\n// to be checked, in the order of preference.\n// @param {Object} options\n// @param {utils/dom/rect~Rect} options.targetRect A rect of the {@link module:utils/dom/position~Options#target}.\n// @param {utils/dom/rect~Rect} options.elementRect A rect of positioned {@link module:utils/dom/position~Options#element}.\n// @param {utils/dom/rect~Rect} options.limiterRect A rect of the {@link module:utils/dom/position~Options#limiter}.\n// @param {utils/dom/rect~Rect} options.viewportRect A rect of the viewport.\n//\n// @returns {Array.<Object>} Array of positions with calculated intersection areas. Each item is an object containing:\n// * {String} positionName Name of position.\n// * {utils/dom/rect~Rect} positionRect Rect of position.\n// * {Number} limiterIntersectArea Area of intersection of the position with limiter part that is in the viewport.\n// * {Number} viewportIntersectArea Area of intersection of the position with viewport.\nfunction processPositionsToAreas( positions, { targetRect, elementRect, limiterRect, viewportRect } ) {\n\tconst processedPositions = [];\n\n\t// This is when element is fully visible.\n\tconst elementRectArea = elementRect.getArea();\n\n\tfor ( const position of positions ) {\n\t\tconst positionData = getPositionNameAndRect( position, targetRect, elementRect );\n\n\t\tif ( !positionData ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst [ positionName, positionRect ] = positionData;\n\t\tlet limiterIntersectArea = 0;\n\t\tlet viewportIntersectArea = 0;\n\n\t\tif ( limiterRect ) {\n\t\t\tif ( viewportRect ) {\n\t\t\t\t// Consider only the part of the limiter which is visible in the viewport. So the limiter is getting limited.\n\t\t\t\tconst limiterViewportIntersectRect = limiterRect.getIntersection( viewportRect );\n\n\t\t\t\tif ( limiterViewportIntersectRect ) {\n\t\t\t\t\t// If the limiter is within the viewport, then check the intersection between that part of the\n\t\t\t\t\t// limiter and actual position.\n\t\t\t\t\tlimiterIntersectArea = limiterViewportIntersectRect.getIntersectionArea( positionRect );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlimiterIntersectArea = limiterRect.getIntersectionArea( positionRect );\n\t\t\t}\n\t\t}\n\n\t\tif ( viewportRect ) {\n\t\t\tviewportIntersectArea = viewportRect.getIntersectionArea( positionRect );\n\t\t}\n\n\t\tconst processedPosition = {\n\t\t\tpositionName,\n\t\t\tpositionRect,\n\t\t\tlimiterIntersectArea,\n\t\t\tviewportIntersectArea\n\t\t};\n\n\t\t// If a such position is found that element is fully contained by the limiter then, obviously,\n\t\t// there will be no better one, so finishing.\n\t\tif ( limiterIntersectArea === elementRectArea ) {\n\t\t\treturn [ processedPosition ];\n\t\t}\n\n\t\tprocessedPositions.push( processedPosition );\n\t}\n\n\treturn processedPositions;\n}\n\n// For a given array of processed position data (with calculated Rects for positions and intersection areas)\n// returns such that provides the best fit of the `elementRect` into the `limiterRect` and `viewportRect` at the same time.\n//\n// **Note**: It will return early if some position fully fits into the `limiterRect`.\n//\n// @private\n// @param {Array.<Object>} Array of positions with calculated intersection areas (in order of preference).\n// Each item is an object containing:\n//\n//\t* {String} positionName Name of position.\n//\t* {utils/dom/rect~Rect} positionRect Rect of position.\n//\t* {Number} limiterIntersectArea Area of intersection of the position with limiter part that is in the viewport.\n//\t* {Number} viewportIntersectArea Area of intersection of the position with viewport.\n//\n// @param {Number} elementRectArea Area of positioned {@link module:utils/dom/position~Options#element}.\n// @returns {Array|null} An array containing the name of the position and it's rect, or null if not found.\nfunction getBestOfProcessedPositions( processedPositions, elementRectArea ) {\n\tlet maxFitFactor = 0;\n\tlet bestPositionRect;\n\tlet bestPositionName;\n\n\tfor ( const { positionName, positionRect, limiterIntersectArea, viewportIntersectArea } of processedPositions ) {\n\t\t// If a such position is found that element is fully container by the limiter then, obviously,\n\t\t// there will be no better one, so finishing.\n\t\tif ( limiterIntersectArea === elementRectArea ) {\n\t\t\treturn [ positionName, positionRect ];\n\t\t}\n\n\t\t// To maximize both viewport and limiter intersection areas we use distance on viewportIntersectArea\n\t\t// and limiterIntersectArea plane (without sqrt because we are looking for max value).\n\t\tconst fitFactor = viewportIntersectArea ** 2 + limiterIntersectArea ** 2;\n\n\t\tif ( fitFactor > maxFitFactor ) {\n\t\t\tmaxFitFactor = fitFactor;\n\t\t\tbestPositionRect = positionRect;\n\t\t\tbestPositionName = positionName;\n\t\t}\n\t}\n\n\treturn bestPositionRect ? [ bestPositionName, bestPositionRect ] : null;\n}\n\n// For a given absolute Rect coordinates object and a positioned element ancestor, it returns an object with\n// new Rect coordinates that make up for the position and the scroll of the ancestor.\n//\n// This is necessary because while Rects (and DOMRects) are relative to the browser's viewport, their coordinates\n// are used in real–life to position elements with `position: absolute`, which are scoped by any positioned\n// (and scrollable) ancestors.\n//\n// @private\n//\n// @param {Object} absoluteRectCoordinates An object with absolute rect coordinates.\n// @param {Object} absoluteRectCoordinates.top\n// @param {Object} absoluteRectCoordinates.left\n// @param {HTMLElement} positionedElementAncestor An ancestor element that should be considered.\n//\n// @returns {Object} An object corresponding to `absoluteRectCoordinates` input but with values shifted\n// to make up for the positioned element ancestor.\nfunction shiftRectCoordinatesDueToPositionedAncestor( { left, top }, positionedElementAncestor ) {\n\tconst ancestorPosition = getAbsoluteRectCoordinates( new Rect( positionedElementAncestor ) );\n\tconst ancestorBorderWidths = getBorderWidths( positionedElementAncestor );\n\n\t// (https://github.com/ckeditor/ckeditor5-ui-default/issues/126)\n\t// If there's some positioned ancestor of the panel, then its `Rect` must be taken into\n\t// consideration. `Rect` is always relative to the viewport while `position: absolute` works\n\t// with respect to that positioned ancestor.\n\tleft -= ancestorPosition.left;\n\ttop -= ancestorPosition.top;\n\n\t// (https://github.com/ckeditor/ckeditor5-utils/issues/139)\n\t// If there's some positioned ancestor of the panel, not only its position must be taken into\n\t// consideration (see above) but also its internal scrolls. Scroll have an impact here because `Rect`\n\t// is relative to the viewport (it doesn't care about scrolling), while `position: absolute`\n\t// must compensate that scrolling.\n\tleft += positionedElementAncestor.scrollLeft;\n\ttop += positionedElementAncestor.scrollTop;\n\n\t// (https://github.com/ckeditor/ckeditor5-utils/issues/139)\n\t// If there's some positioned ancestor of the panel, then its `Rect` includes its CSS `borderWidth`\n\t// while `position: absolute` positioning does not consider it.\n\t// E.g. `{ position: absolute, top: 0, left: 0 }` means upper left corner of the element,\n\t// not upper-left corner of its border.\n\tleft -= ancestorBorderWidths.left;\n\ttop -= ancestorBorderWidths.top;\n\n\treturn { left, top };\n}\n\n// DOMRect (also Rect) works in a scroll–independent geometry but `position: absolute` doesn't.\n// This function converts Rect to `position: absolute` coordinates.\n//\n// @private\n// @param {utils/dom/rect~Rect} rect A rect to be converted.\n// @returns {Object} Object containing `left` and `top` properties, in absolute coordinates.\nfunction getAbsoluteRectCoordinates( { left, top } ) {\n\tconst { scrollX, scrollY } = global.window;\n\n\treturn {\n\t\tleft: left + scrollX,\n\t\ttop: top + scrollY\n\t};\n}\n\n/**\n * The `getOptimalPosition()` helper options.\n *\n * @interface module:utils/dom/position~Options\n */\n\n/**\n * Element that is to be positioned.\n *\n * @member {HTMLElement} #element\n */\n\n/**\n * Target with respect to which the `element` is to be positioned.\n *\n * @member {HTMLElement|Range|Window|ClientRect|DOMRect|module:utils/dom/rect~Rect|Object|Function} #target\n */\n\n/**\n * An array of functions which return {@link module:utils/dom/position~Position} relative\n * to the `target`, in the order of preference.\n *\n * **Note**: If a function returns `null`, it is ignored by the `getOptimalPosition()`.\n *\n * @member {Array.<Function>} #positions\n */\n\n/**\n * When set, the algorithm will chose position which fits the most in the\n * limiter's bounding rect.\n *\n * @member {HTMLElement|Range|Window|ClientRect|DOMRect|module:utils/dom/rect~Rect|Object|Function} #limiter\n */\n\n/**\n * When set, the algorithm will chose such a position which fits `element`\n * the most inside visible viewport.\n *\n * @member {Boolean} #fitInViewport\n */\n\n/**\n * An object describing a position in `position: absolute` coordinate\n * system, along with position name.\n *\n * @typedef {Object} module:utils/dom/position~Position\n *\n * @property {Number} top Top position offset.\n * @property {Number} left Left position offset.\n * @property {String} name Name of the position.\n */\n"]},"metadata":{},"sourceType":"module"}