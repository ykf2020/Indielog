{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module widget/utils\n */\nimport BalloonPanelView from '@ckeditor/ckeditor5-ui/src/panel/balloon/balloonpanelview';\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\nimport Rect from '@ckeditor/ckeditor5-utils/src/dom/rect';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport toArray from '@ckeditor/ckeditor5-utils/src/toarray';\nimport HighlightStack from './highlightstack';\nimport { getTypeAroundFakeCaretPosition } from './widgettypearound/utils';\nimport IconView from '@ckeditor/ckeditor5-ui/src/icon/iconview';\nimport dragHandleIcon from '../theme/icons/drag-handle.svg';\n/**\n * CSS class added to each widget element.\n *\n * @const {String}\n */\n\nexport const WIDGET_CLASS_NAME = 'ck-widget';\n/**\n * CSS class added to currently selected widget element.\n *\n * @const {String}\n */\n\nexport const WIDGET_SELECTED_CLASS_NAME = 'ck-widget_selected';\n/**\n * Returns `true` if given {@link module:engine/view/node~Node} is an {@link module:engine/view/element~Element} and a widget.\n *\n * @param {module:engine/view/node~Node} node\n * @returns {Boolean}\n */\n\nexport function isWidget(node) {\n  if (!node.is('element')) {\n    return false;\n  }\n\n  return !!node.getCustomProperty('widget');\n}\n/**\n * Converts the given {@link module:engine/view/element~Element} to a widget in the following way:\n *\n * * sets the `contenteditable` attribute to `\"false\"`,\n * * adds the `ck-widget` CSS class,\n * * adds a custom {@link module:engine/view/element~Element#getFillerOffset `getFillerOffset()`} method returning `null`,\n * * adds a custom property allowing to recognize widget elements by using {@link ~isWidget `isWidget()`},\n * * implements the {@link ~setHighlightHandling view highlight on widgets}.\n *\n * This function needs to be used in conjunction with\n * {@link module:engine/conversion/downcasthelpers~DowncastHelpers downcast conversion helpers}\n * like {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`}.\n * Moreover, typically you will want to use `toWidget()` only for `editingDowncast`, while keeping the `dataDowncast` clean.\n *\n * For example, in order to convert a `<widget>` model element to `<div class=\"widget\">` in the view, you can define\n * such converters:\n *\n *\t\teditor.conversion.for( 'editingDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'widget',\n *\t\t\t\tview: ( modelItem, { writer } ) => {\n *\t\t\t\t\tconst div = writer.createContainerElement( 'div', { class: 'widget' } );\n *\n *\t\t\t\t\treturn toWidget( div, writer, { label: 'some widget' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n *\t\teditor.conversion.for( 'dataDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'widget',\n *\t\t\t\tview: ( modelItem, { writer } ) => {\n *\t\t\t\t\treturn writer.createContainerElement( 'div', { class: 'widget' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n * See the full source code of the widget (with a nested editable) schema definition and converters in\n * [this sample](https://github.com/ckeditor/ckeditor5-widget/blob/master/tests/manual/widget-with-nestededitable.js).\n *\n * @param {module:engine/view/element~Element} element\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {Object} [options={}]\n * @param {String|Function} [options.label] Element's label provided to the {@link ~setLabel} function. It can be passed as\n * a plain string or a function returning a string. It represents the widget for assistive technologies (like screen readers).\n * @param {Boolean} [options.hasSelectionHandle=false] If `true`, the widget will have a selection handle added.\n * @returns {module:engine/view/element~Element} Returns the same element.\n */\n\nexport function toWidget(element, writer, options = {}) {\n  if (!element.is('containerElement')) {\n    /**\n     * The element passed to `toWidget()` must be a {@link module:engine/view/containerelement~ContainerElement}\n     * instance.\n     *\n     * @error widget-to-widget-wrong-element-type\n     * @param {String} element The view element passed to `toWidget()`.\n     */\n    throw new CKEditorError('widget-to-widget-wrong-element-type', null, {\n      element\n    });\n  }\n\n  writer.setAttribute('contenteditable', 'false', element);\n  writer.addClass(WIDGET_CLASS_NAME, element);\n  writer.setCustomProperty('widget', true, element);\n  element.getFillerOffset = getFillerOffset;\n\n  if (options.label) {\n    setLabel(element, options.label, writer);\n  }\n\n  if (options.hasSelectionHandle) {\n    addSelectionHandle(element, writer);\n  }\n\n  setHighlightHandling(element, writer, addHighlight, removeHighlight);\n  return element;\n} // Default handler for adding a highlight on a widget.\n// It adds CSS class and attributes basing on the given highlight descriptor.\n//\n// @param {module:engine/view/element~Element} element\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} descriptor\n// @param {module:engine/view/downcastwriter~DowncastWriter} writer\n\nfunction addHighlight(element, descriptor, writer) {\n  if (descriptor.classes) {\n    writer.addClass(toArray(descriptor.classes), element);\n  }\n\n  if (descriptor.attributes) {\n    for (const key in descriptor.attributes) {\n      writer.setAttribute(key, descriptor.attributes[key], element);\n    }\n  }\n} // Default handler for removing a highlight from a widget.\n// It removes CSS class and attributes basing on the given highlight descriptor.\n//\n// @param {module:engine/view/element~Element} element\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} descriptor\n// @param {module:engine/view/downcastwriter~DowncastWriter} writer\n\n\nfunction removeHighlight(element, descriptor, writer) {\n  if (descriptor.classes) {\n    writer.removeClass(toArray(descriptor.classes), element);\n  }\n\n  if (descriptor.attributes) {\n    for (const key in descriptor.attributes) {\n      writer.removeAttribute(key, element);\n    }\n  }\n}\n/**\n * Sets highlight handling methods. Uses {@link module:widget/highlightstack~HighlightStack} to\n * properly determine which highlight descriptor should be used at given time.\n *\n * @param {module:engine/view/element~Element} element\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {Function} add\n * @param {Function} remove\n */\n\n\nexport function setHighlightHandling(element, writer, add, remove) {\n  const stack = new HighlightStack();\n  stack.on('change:top', (evt, data) => {\n    if (data.oldDescriptor) {\n      remove(element, data.oldDescriptor, data.writer);\n    }\n\n    if (data.newDescriptor) {\n      add(element, data.newDescriptor, data.writer);\n    }\n  });\n  writer.setCustomProperty('addHighlight', (element, descriptor, writer) => stack.add(descriptor, writer), element);\n  writer.setCustomProperty('removeHighlight', (element, id, writer) => stack.remove(id, writer), element);\n}\n/**\n * Sets label for given element.\n * It can be passed as a plain string or a function returning a string. Function will be called each time label is retrieved by\n * {@link ~getLabel `getLabel()`}.\n *\n * @param {module:engine/view/element~Element} element\n * @param {String|Function} labelOrCreator\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n */\n\nexport function setLabel(element, labelOrCreator, writer) {\n  writer.setCustomProperty('widgetLabel', labelOrCreator, element);\n}\n/**\n * Returns the label of the provided element.\n *\n * @param {module:engine/view/element~Element} element\n * @returns {String}\n */\n\nexport function getLabel(element) {\n  const labelCreator = element.getCustomProperty('widgetLabel');\n\n  if (!labelCreator) {\n    return '';\n  }\n\n  return typeof labelCreator == 'function' ? labelCreator() : labelCreator;\n}\n/**\n * Adds functionality to the provided {@link module:engine/view/editableelement~EditableElement} to act as a widget's editable:\n *\n * * sets the `contenteditable` attribute to `true` when {@link module:engine/view/editableelement~EditableElement#isReadOnly} is `false`,\n * otherwise sets it to `false`,\n * * adds the `ck-editor__editable` and `ck-editor__nested-editable` CSS classes,\n * * adds the `ck-editor__nested-editable_focused` CSS class when the editable is focused and removes it when it is blurred.\n *\n * Similarly to {@link ~toWidget `toWidget()`} this function should be used in `editingDowncast` only and it is usually\n * used together with {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`}.\n *\n * For example, in order to convert a `<nested>` model element to `<div class=\"nested\">` in the view, you can define\n * such converters:\n *\n *\t\teditor.conversion.for( 'editingDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'nested',\n *\t\t\t\tview: ( modelItem, { writer } ) => {\n *\t\t\t\t\tconst div = writer.createEditableElement( 'div', { class: 'nested' } );\n *\n *\t\t\t\t\treturn toWidgetEditable( nested, writer );\n *\t\t\t\t}\n *\t\t\t} );\n *\n *\t\teditor.conversion.for( 'dataDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'nested',\n *\t\t\t\tview: ( modelItem, { writer } ) => {\n *\t\t\t\t\treturn writer.createContainerElement( 'div', { class: 'nested' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n * See the full source code of the widget (with nested editable) schema definition and converters in\n * [this sample](https://github.com/ckeditor/ckeditor5-widget/blob/master/tests/manual/widget-with-nestededitable.js).\n *\n * @param {module:engine/view/editableelement~EditableElement} editable\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @returns {module:engine/view/editableelement~EditableElement} Returns the same element that was provided in the `editable` parameter\n */\n\nexport function toWidgetEditable(editable, writer) {\n  writer.addClass(['ck-editor__editable', 'ck-editor__nested-editable'], editable); // Set initial contenteditable value.\n\n  writer.setAttribute('contenteditable', editable.isReadOnly ? 'false' : 'true', editable); // Bind the contenteditable property to element#isReadOnly.\n\n  editable.on('change:isReadOnly', (evt, property, is) => {\n    writer.setAttribute('contenteditable', is ? 'false' : 'true', editable);\n  });\n  editable.on('change:isFocused', (evt, property, is) => {\n    if (is) {\n      writer.addClass('ck-editor__nested-editable_focused', editable);\n    } else {\n      writer.removeClass('ck-editor__nested-editable_focused', editable);\n    }\n  });\n  return editable;\n}\n/**\n * Returns a model range which is optimal (in terms of UX) for inserting a widget block.\n *\n * For instance, if a selection is in the middle of a paragraph, the collapsed range before this paragraph\n * will be returned so that it is not split. If the selection is at the end of a paragraph,\n * the collapsed range after this paragraph will be returned.\n *\n * Note: If the selection is placed in an empty block, the range in that block will be returned. If that range\n * is then passed to {@link module:engine/model/model~Model#insertContent}, the block will be fully replaced\n * by the inserted widget block.\n *\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * The selection based on which the insertion position should be calculated.\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {module:engine/model/range~Range} The optimal range.\n */\n\nexport function findOptimalInsertionRange(selection, model) {\n  const selectedElement = selection.getSelectedElement();\n\n  if (selectedElement) {\n    const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(selection); // If the WidgetTypeAround \"fake caret\" is displayed, use its position for the insertion\n    // to provide the most predictable UX (https://github.com/ckeditor/ckeditor5/issues/7438).\n\n    if (typeAroundFakeCaretPosition) {\n      return model.createRange(model.createPositionAt(selectedElement, typeAroundFakeCaretPosition));\n    }\n\n    if (model.schema.isObject(selectedElement) && !model.schema.isInline(selectedElement)) {\n      return model.createRangeOn(selectedElement);\n    }\n  }\n\n  const firstBlock = selection.getSelectedBlocks().next().value;\n\n  if (firstBlock) {\n    // If inserting into an empty block – return position in that block. It will get\n    // replaced with the image by insertContent(). #42.\n    if (firstBlock.isEmpty) {\n      return model.createRange(model.createPositionAt(firstBlock, 0));\n    }\n\n    const positionAfter = model.createPositionAfter(firstBlock); // If selection is at the end of the block - return position after the block.\n\n    if (selection.focus.isTouching(positionAfter)) {\n      return model.createRange(positionAfter);\n    } // Otherwise return position before the block.\n\n\n    return model.createRange(model.createPositionBefore(firstBlock));\n  }\n\n  return model.createRange(selection.focus);\n}\n/**\n * A util to be used in order to map view positions to correct model positions when implementing a widget\n * which renders non-empty view element for an empty model element.\n *\n * For example:\n *\n *\t\t// Model:\n *\t\t<placeholder type=\"name\"></placeholder>\n *\n *\t\t// View:\n *\t\t<span class=\"placeholder\">name</span>\n *\n * In such case, view positions inside `<span>` cannot be correct mapped to the model (because the model element is empty).\n * To handle mapping positions inside `<span class=\"placeholder\">` to the model use this util as follows:\n *\n *\t\teditor.editing.mapper.on(\n *\t\t\t'viewToModelPosition',\n *\t\t\tviewToModelPositionOutsideModelElement( model, viewElement => viewElement.hasClass( 'placeholder' ) )\n *\t\t);\n *\n * The callback will try to map the view offset of selection to an expected model position.\n *\n * 1. When the position is at the end (or in the middle) of the inline widget:\n *\n *\t\t// View:\n *\t\t<p>foo <span class=\"placeholder\">name|</span> bar</p>\n *\n *\t\t// Model:\n *\t\t<paragraph>foo <placeholder type=\"name\"></placeholder>| bar</paragraph>\n *\n * 2. When the position is at the beginning of the inline widget:\n *\n *\t\t// View:\n *\t\t<p>foo <span class=\"placeholder\">|name</span> bar</p>\n *\n *\t\t// Model:\n *\t\t<paragraph>foo |<placeholder type=\"name\"></placeholder> bar</paragraph>\n *\n * @param {module:engine/model/model~Model} model Model instance on which the callback operates.\n * @param {Function} viewElementMatcher Function that is passed a view element and should return `true` if the custom mapping\n * should be applied to the given view element.\n * @return {Function}\n */\n\nexport function viewToModelPositionOutsideModelElement(model, viewElementMatcher) {\n  return (evt, data) => {\n    const {\n      mapper,\n      viewPosition\n    } = data;\n    const viewParent = mapper.findMappedViewAncestor(viewPosition);\n\n    if (!viewElementMatcher(viewParent)) {\n      return;\n    }\n\n    const modelParent = mapper.toModelElement(viewParent);\n    data.modelPosition = model.createPositionAt(modelParent, viewPosition.isAtStart ? 'before' : 'after');\n  };\n}\n/**\n * A positioning function passed to the {@link module:utils/dom/position~getOptimalPosition} helper as a last resort\n * when attaching {@link  module:ui/panel/balloon/balloonpanelview~BalloonPanelView balloon UI} to widgets.\n * It comes in handy when a widget is longer than the visual viewport of the web browser and/or upper/lower boundaries\n * of a widget are off screen because of the web page scroll.\n *\n *\t                                       ┌─┄┄┄┄┄┄┄┄┄Widget┄┄┄┄┄┄┄┄┄┐\n *\t                                       ┊                         ┊\n *\t┌────────────Viewport───────────┐   ┌──╁─────────Viewport────────╁──┐\n *\t│  ┏━━━━━━━━━━Widget━━━━━━━━━┓  │   │  ┃            ^            ┃  │\n *\t│  ┃            ^            ┃  │   │  ┃   ╭───────/ \\───────╮   ┃  │\n *\t│  ┃   ╭───────/ \\───────╮   ┃  │   │  ┃   │     Balloon     │   ┃  │\n *\t│  ┃   │     Balloon     │   ┃  │   │  ┃   ╰─────────────────╯   ┃  │\n *\t│  ┃   ╰─────────────────╯   ┃  │   │  ┃                         ┃  │\n *\t│  ┃                         ┃  │   │  ┃                         ┃  │\n *\t│  ┃                         ┃  │   │  ┃                         ┃  │\n *\t│  ┃                         ┃  │   │  ┃                         ┃  │\n *\t│  ┃                         ┃  │   │  ┃                         ┃  │\n *\t│  ┃                         ┃  │   │  ┃                         ┃  │\n *\t│  ┃                         ┃  │   │  ┃                         ┃  │\n *\t└──╀─────────────────────────╀──┘   └──╀─────────────────────────╀──┘\n *\t   ┊                         ┊         ┊                         ┊\n *\t   ┊                         ┊         └┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┘\n *\t   ┊                         ┊\n *\t   └┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┘\n *\n * **Note**: Works best if used together with\n * {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions default `BalloonPanelView` positions}\n * like `northArrowSouth` and `southArrowNorth`; the transition between these two and this position is smooth.\n *\n * @param {module:utils/dom/rect~Rect} widgetRect A rect of the widget.\n * @param {module:utils/dom/rect~Rect} balloonRect A rect of the balloon.\n * @returns {module:utils/dom/position~Position|null}\n */\n\nexport function centeredBalloonPositionForLongWidgets(widgetRect, balloonRect) {\n  const viewportRect = new Rect(global.window);\n  const viewportWidgetInsersectionRect = viewportRect.getIntersection(widgetRect);\n  const balloonTotalHeight = balloonRect.height + BalloonPanelView.arrowVerticalOffset; // If there is enough space above or below the widget then this position should not be used.\n\n  if (widgetRect.top - balloonTotalHeight > viewportRect.top || widgetRect.bottom + balloonTotalHeight < viewportRect.bottom) {\n    return null;\n  } // Because this is a last resort positioning, to keep things simple we're not playing with positions of the arrow\n  // like, for instance, \"south west\" or whatever. Just try to keep the balloon in the middle of the visible area of\n  // the widget for as long as it is possible. If the widgets becomes invisible (because cropped by the viewport),\n  // just... place the balloon in the middle of it (because why not?).\n\n\n  const targetRect = viewportWidgetInsersectionRect || widgetRect;\n  const left = targetRect.left + targetRect.width / 2 - balloonRect.width / 2;\n  return {\n    top: Math.max(widgetRect.top, 0) + BalloonPanelView.arrowVerticalOffset,\n    left,\n    name: 'arrow_n'\n  };\n} // Default filler offset function applied to all widget elements.\n//\n// @returns {null}\n\nfunction getFillerOffset() {\n  return null;\n} // Adds a drag handle to the widget.\n//\n// @param {module:engine/view/containerelement~ContainerElement}\n// @param {module:engine/view/downcastwriter~DowncastWriter} writer\n\n\nfunction addSelectionHandle(widgetElement, writer) {\n  const selectionHandle = writer.createUIElement('div', {\n    class: 'ck ck-widget__selection-handle'\n  }, function (domDocument) {\n    const domElement = this.toDomElement(domDocument); // Use the IconView from the ui library.\n\n    const icon = new IconView();\n    icon.set('content', dragHandleIcon); // Render the icon view right away to append its #element to the selectionHandle DOM element.\n\n    icon.render();\n    domElement.appendChild(icon.element);\n    return domElement;\n  }); // Append the selection handle into the widget wrapper.\n\n  writer.insert(writer.createPositionAt(widgetElement, 0), selectionHandle);\n  writer.addClass(['ck-widget_with-selection-handle'], widgetElement);\n}","map":{"version":3,"sources":["/Users/fanyukun/Documents/react/indielog/node_modules/@ckeditor/ckeditor5-widget/src/utils.js"],"names":["BalloonPanelView","global","Rect","CKEditorError","toArray","HighlightStack","getTypeAroundFakeCaretPosition","IconView","dragHandleIcon","WIDGET_CLASS_NAME","WIDGET_SELECTED_CLASS_NAME","isWidget","node","is","getCustomProperty","toWidget","element","writer","options","setAttribute","addClass","setCustomProperty","getFillerOffset","label","setLabel","hasSelectionHandle","addSelectionHandle","setHighlightHandling","addHighlight","removeHighlight","descriptor","classes","attributes","key","removeClass","removeAttribute","add","remove","stack","on","evt","data","oldDescriptor","newDescriptor","id","labelOrCreator","getLabel","labelCreator","toWidgetEditable","editable","isReadOnly","property","findOptimalInsertionRange","selection","model","selectedElement","getSelectedElement","typeAroundFakeCaretPosition","createRange","createPositionAt","schema","isObject","isInline","createRangeOn","firstBlock","getSelectedBlocks","next","value","isEmpty","positionAfter","createPositionAfter","focus","isTouching","createPositionBefore","viewToModelPositionOutsideModelElement","viewElementMatcher","mapper","viewPosition","viewParent","findMappedViewAncestor","modelParent","toModelElement","modelPosition","isAtStart","centeredBalloonPositionForLongWidgets","widgetRect","balloonRect","viewportRect","window","viewportWidgetInsersectionRect","getIntersection","balloonTotalHeight","height","arrowVerticalOffset","top","bottom","targetRect","left","width","Math","max","name","widgetElement","selectionHandle","createUIElement","class","domDocument","domElement","toDomElement","icon","set","render","appendChild","insert"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2021, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module widget/utils\n */\n\nimport BalloonPanelView from '@ckeditor/ckeditor5-ui/src/panel/balloon/balloonpanelview';\n\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\nimport Rect from '@ckeditor/ckeditor5-utils/src/dom/rect';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport toArray from '@ckeditor/ckeditor5-utils/src/toarray';\n\nimport HighlightStack from './highlightstack';\nimport { getTypeAroundFakeCaretPosition } from './widgettypearound/utils';\n\nimport IconView from '@ckeditor/ckeditor5-ui/src/icon/iconview';\nimport dragHandleIcon from '../theme/icons/drag-handle.svg';\n\n/**\n * CSS class added to each widget element.\n *\n * @const {String}\n */\nexport const WIDGET_CLASS_NAME = 'ck-widget';\n\n/**\n * CSS class added to currently selected widget element.\n *\n * @const {String}\n */\nexport const WIDGET_SELECTED_CLASS_NAME = 'ck-widget_selected';\n\n/**\n * Returns `true` if given {@link module:engine/view/node~Node} is an {@link module:engine/view/element~Element} and a widget.\n *\n * @param {module:engine/view/node~Node} node\n * @returns {Boolean}\n */\nexport function isWidget( node ) {\n\tif ( !node.is( 'element' ) ) {\n\t\treturn false;\n\t}\n\n\treturn !!node.getCustomProperty( 'widget' );\n}\n\n/**\n * Converts the given {@link module:engine/view/element~Element} to a widget in the following way:\n *\n * * sets the `contenteditable` attribute to `\"false\"`,\n * * adds the `ck-widget` CSS class,\n * * adds a custom {@link module:engine/view/element~Element#getFillerOffset `getFillerOffset()`} method returning `null`,\n * * adds a custom property allowing to recognize widget elements by using {@link ~isWidget `isWidget()`},\n * * implements the {@link ~setHighlightHandling view highlight on widgets}.\n *\n * This function needs to be used in conjunction with\n * {@link module:engine/conversion/downcasthelpers~DowncastHelpers downcast conversion helpers}\n * like {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`}.\n * Moreover, typically you will want to use `toWidget()` only for `editingDowncast`, while keeping the `dataDowncast` clean.\n *\n * For example, in order to convert a `<widget>` model element to `<div class=\"widget\">` in the view, you can define\n * such converters:\n *\n *\t\teditor.conversion.for( 'editingDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'widget',\n *\t\t\t\tview: ( modelItem, { writer } ) => {\n *\t\t\t\t\tconst div = writer.createContainerElement( 'div', { class: 'widget' } );\n *\n *\t\t\t\t\treturn toWidget( div, writer, { label: 'some widget' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n *\t\teditor.conversion.for( 'dataDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'widget',\n *\t\t\t\tview: ( modelItem, { writer } ) => {\n *\t\t\t\t\treturn writer.createContainerElement( 'div', { class: 'widget' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n * See the full source code of the widget (with a nested editable) schema definition and converters in\n * [this sample](https://github.com/ckeditor/ckeditor5-widget/blob/master/tests/manual/widget-with-nestededitable.js).\n *\n * @param {module:engine/view/element~Element} element\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {Object} [options={}]\n * @param {String|Function} [options.label] Element's label provided to the {@link ~setLabel} function. It can be passed as\n * a plain string or a function returning a string. It represents the widget for assistive technologies (like screen readers).\n * @param {Boolean} [options.hasSelectionHandle=false] If `true`, the widget will have a selection handle added.\n * @returns {module:engine/view/element~Element} Returns the same element.\n */\nexport function toWidget( element, writer, options = {} ) {\n\tif ( !element.is( 'containerElement' ) ) {\n\t\t/**\n\t\t * The element passed to `toWidget()` must be a {@link module:engine/view/containerelement~ContainerElement}\n\t\t * instance.\n\t\t *\n\t\t * @error widget-to-widget-wrong-element-type\n\t\t * @param {String} element The view element passed to `toWidget()`.\n\t\t */\n\t\tthrow new CKEditorError(\n\t\t\t'widget-to-widget-wrong-element-type',\n\t\t\tnull,\n\t\t\t{ element }\n\t\t);\n\t}\n\n\twriter.setAttribute( 'contenteditable', 'false', element );\n\n\twriter.addClass( WIDGET_CLASS_NAME, element );\n\twriter.setCustomProperty( 'widget', true, element );\n\telement.getFillerOffset = getFillerOffset;\n\n\tif ( options.label ) {\n\t\tsetLabel( element, options.label, writer );\n\t}\n\n\tif ( options.hasSelectionHandle ) {\n\t\taddSelectionHandle( element, writer );\n\t}\n\n\tsetHighlightHandling( element, writer, addHighlight, removeHighlight );\n\n\treturn element;\n}\n\n// Default handler for adding a highlight on a widget.\n// It adds CSS class and attributes basing on the given highlight descriptor.\n//\n// @param {module:engine/view/element~Element} element\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} descriptor\n// @param {module:engine/view/downcastwriter~DowncastWriter} writer\nfunction addHighlight( element, descriptor, writer ) {\n\tif ( descriptor.classes ) {\n\t\twriter.addClass( toArray( descriptor.classes ), element );\n\t}\n\n\tif ( descriptor.attributes ) {\n\t\tfor ( const key in descriptor.attributes ) {\n\t\t\twriter.setAttribute( key, descriptor.attributes[ key ], element );\n\t\t}\n\t}\n}\n\n// Default handler for removing a highlight from a widget.\n// It removes CSS class and attributes basing on the given highlight descriptor.\n//\n// @param {module:engine/view/element~Element} element\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} descriptor\n// @param {module:engine/view/downcastwriter~DowncastWriter} writer\nfunction removeHighlight( element, descriptor, writer ) {\n\tif ( descriptor.classes ) {\n\t\twriter.removeClass( toArray( descriptor.classes ), element );\n\t}\n\n\tif ( descriptor.attributes ) {\n\t\tfor ( const key in descriptor.attributes ) {\n\t\t\twriter.removeAttribute( key, element );\n\t\t}\n\t}\n}\n\n/**\n * Sets highlight handling methods. Uses {@link module:widget/highlightstack~HighlightStack} to\n * properly determine which highlight descriptor should be used at given time.\n *\n * @param {module:engine/view/element~Element} element\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {Function} add\n * @param {Function} remove\n */\nexport function setHighlightHandling( element, writer, add, remove ) {\n\tconst stack = new HighlightStack();\n\n\tstack.on( 'change:top', ( evt, data ) => {\n\t\tif ( data.oldDescriptor ) {\n\t\t\tremove( element, data.oldDescriptor, data.writer );\n\t\t}\n\n\t\tif ( data.newDescriptor ) {\n\t\t\tadd( element, data.newDescriptor, data.writer );\n\t\t}\n\t} );\n\n\twriter.setCustomProperty( 'addHighlight', ( element, descriptor, writer ) => stack.add( descriptor, writer ), element );\n\twriter.setCustomProperty( 'removeHighlight', ( element, id, writer ) => stack.remove( id, writer ), element );\n}\n\n/**\n * Sets label for given element.\n * It can be passed as a plain string or a function returning a string. Function will be called each time label is retrieved by\n * {@link ~getLabel `getLabel()`}.\n *\n * @param {module:engine/view/element~Element} element\n * @param {String|Function} labelOrCreator\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n */\nexport function setLabel( element, labelOrCreator, writer ) {\n\twriter.setCustomProperty( 'widgetLabel', labelOrCreator, element );\n}\n\n/**\n * Returns the label of the provided element.\n *\n * @param {module:engine/view/element~Element} element\n * @returns {String}\n */\nexport function getLabel( element ) {\n\tconst labelCreator = element.getCustomProperty( 'widgetLabel' );\n\n\tif ( !labelCreator ) {\n\t\treturn '';\n\t}\n\n\treturn typeof labelCreator == 'function' ? labelCreator() : labelCreator;\n}\n\n/**\n * Adds functionality to the provided {@link module:engine/view/editableelement~EditableElement} to act as a widget's editable:\n *\n * * sets the `contenteditable` attribute to `true` when {@link module:engine/view/editableelement~EditableElement#isReadOnly} is `false`,\n * otherwise sets it to `false`,\n * * adds the `ck-editor__editable` and `ck-editor__nested-editable` CSS classes,\n * * adds the `ck-editor__nested-editable_focused` CSS class when the editable is focused and removes it when it is blurred.\n *\n * Similarly to {@link ~toWidget `toWidget()`} this function should be used in `editingDowncast` only and it is usually\n * used together with {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`}.\n *\n * For example, in order to convert a `<nested>` model element to `<div class=\"nested\">` in the view, you can define\n * such converters:\n *\n *\t\teditor.conversion.for( 'editingDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'nested',\n *\t\t\t\tview: ( modelItem, { writer } ) => {\n *\t\t\t\t\tconst div = writer.createEditableElement( 'div', { class: 'nested' } );\n *\n *\t\t\t\t\treturn toWidgetEditable( nested, writer );\n *\t\t\t\t}\n *\t\t\t} );\n *\n *\t\teditor.conversion.for( 'dataDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'nested',\n *\t\t\t\tview: ( modelItem, { writer } ) => {\n *\t\t\t\t\treturn writer.createContainerElement( 'div', { class: 'nested' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n * See the full source code of the widget (with nested editable) schema definition and converters in\n * [this sample](https://github.com/ckeditor/ckeditor5-widget/blob/master/tests/manual/widget-with-nestededitable.js).\n *\n * @param {module:engine/view/editableelement~EditableElement} editable\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @returns {module:engine/view/editableelement~EditableElement} Returns the same element that was provided in the `editable` parameter\n */\nexport function toWidgetEditable( editable, writer ) {\n\twriter.addClass( [ 'ck-editor__editable', 'ck-editor__nested-editable' ], editable );\n\n\t// Set initial contenteditable value.\n\twriter.setAttribute( 'contenteditable', editable.isReadOnly ? 'false' : 'true', editable );\n\n\t// Bind the contenteditable property to element#isReadOnly.\n\teditable.on( 'change:isReadOnly', ( evt, property, is ) => {\n\t\twriter.setAttribute( 'contenteditable', is ? 'false' : 'true', editable );\n\t} );\n\n\teditable.on( 'change:isFocused', ( evt, property, is ) => {\n\t\tif ( is ) {\n\t\t\twriter.addClass( 'ck-editor__nested-editable_focused', editable );\n\t\t} else {\n\t\t\twriter.removeClass( 'ck-editor__nested-editable_focused', editable );\n\t\t}\n\t} );\n\n\treturn editable;\n}\n\n/**\n * Returns a model range which is optimal (in terms of UX) for inserting a widget block.\n *\n * For instance, if a selection is in the middle of a paragraph, the collapsed range before this paragraph\n * will be returned so that it is not split. If the selection is at the end of a paragraph,\n * the collapsed range after this paragraph will be returned.\n *\n * Note: If the selection is placed in an empty block, the range in that block will be returned. If that range\n * is then passed to {@link module:engine/model/model~Model#insertContent}, the block will be fully replaced\n * by the inserted widget block.\n *\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * The selection based on which the insertion position should be calculated.\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {module:engine/model/range~Range} The optimal range.\n */\nexport function findOptimalInsertionRange( selection, model ) {\n\tconst selectedElement = selection.getSelectedElement();\n\n\tif ( selectedElement ) {\n\t\tconst typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition( selection );\n\n\t\t// If the WidgetTypeAround \"fake caret\" is displayed, use its position for the insertion\n\t\t// to provide the most predictable UX (https://github.com/ckeditor/ckeditor5/issues/7438).\n\t\tif ( typeAroundFakeCaretPosition ) {\n\t\t\treturn model.createRange( model.createPositionAt( selectedElement, typeAroundFakeCaretPosition ) );\n\t\t}\n\n\t\tif ( model.schema.isObject( selectedElement ) && !model.schema.isInline( selectedElement ) ) {\n\t\t\treturn model.createRangeOn( selectedElement );\n\t\t}\n\t}\n\n\tconst firstBlock = selection.getSelectedBlocks().next().value;\n\n\tif ( firstBlock ) {\n\t\t// If inserting into an empty block – return position in that block. It will get\n\t\t// replaced with the image by insertContent(). #42.\n\t\tif ( firstBlock.isEmpty ) {\n\t\t\treturn model.createRange( model.createPositionAt( firstBlock, 0 ) );\n\t\t}\n\n\t\tconst positionAfter = model.createPositionAfter( firstBlock );\n\n\t\t// If selection is at the end of the block - return position after the block.\n\t\tif ( selection.focus.isTouching( positionAfter ) ) {\n\t\t\treturn model.createRange( positionAfter );\n\t\t}\n\n\t\t// Otherwise return position before the block.\n\t\treturn model.createRange( model.createPositionBefore( firstBlock ) );\n\t}\n\n\treturn model.createRange( selection.focus );\n}\n\n/**\n * A util to be used in order to map view positions to correct model positions when implementing a widget\n * which renders non-empty view element for an empty model element.\n *\n * For example:\n *\n *\t\t// Model:\n *\t\t<placeholder type=\"name\"></placeholder>\n *\n *\t\t// View:\n *\t\t<span class=\"placeholder\">name</span>\n *\n * In such case, view positions inside `<span>` cannot be correct mapped to the model (because the model element is empty).\n * To handle mapping positions inside `<span class=\"placeholder\">` to the model use this util as follows:\n *\n *\t\teditor.editing.mapper.on(\n *\t\t\t'viewToModelPosition',\n *\t\t\tviewToModelPositionOutsideModelElement( model, viewElement => viewElement.hasClass( 'placeholder' ) )\n *\t\t);\n *\n * The callback will try to map the view offset of selection to an expected model position.\n *\n * 1. When the position is at the end (or in the middle) of the inline widget:\n *\n *\t\t// View:\n *\t\t<p>foo <span class=\"placeholder\">name|</span> bar</p>\n *\n *\t\t// Model:\n *\t\t<paragraph>foo <placeholder type=\"name\"></placeholder>| bar</paragraph>\n *\n * 2. When the position is at the beginning of the inline widget:\n *\n *\t\t// View:\n *\t\t<p>foo <span class=\"placeholder\">|name</span> bar</p>\n *\n *\t\t// Model:\n *\t\t<paragraph>foo |<placeholder type=\"name\"></placeholder> bar</paragraph>\n *\n * @param {module:engine/model/model~Model} model Model instance on which the callback operates.\n * @param {Function} viewElementMatcher Function that is passed a view element and should return `true` if the custom mapping\n * should be applied to the given view element.\n * @return {Function}\n */\nexport function viewToModelPositionOutsideModelElement( model, viewElementMatcher ) {\n\treturn ( evt, data ) => {\n\t\tconst { mapper, viewPosition } = data;\n\n\t\tconst viewParent = mapper.findMappedViewAncestor( viewPosition );\n\n\t\tif ( !viewElementMatcher( viewParent ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modelParent = mapper.toModelElement( viewParent );\n\n\t\tdata.modelPosition = model.createPositionAt( modelParent, viewPosition.isAtStart ? 'before' : 'after' );\n\t};\n}\n\n/**\n * A positioning function passed to the {@link module:utils/dom/position~getOptimalPosition} helper as a last resort\n * when attaching {@link  module:ui/panel/balloon/balloonpanelview~BalloonPanelView balloon UI} to widgets.\n * It comes in handy when a widget is longer than the visual viewport of the web browser and/or upper/lower boundaries\n * of a widget are off screen because of the web page scroll.\n *\n *\t                                       ┌─┄┄┄┄┄┄┄┄┄Widget┄┄┄┄┄┄┄┄┄┐\n *\t                                       ┊                         ┊\n *\t┌────────────Viewport───────────┐   ┌──╁─────────Viewport────────╁──┐\n *\t│  ┏━━━━━━━━━━Widget━━━━━━━━━┓  │   │  ┃            ^            ┃  │\n *\t│  ┃            ^            ┃  │   │  ┃   ╭───────/ \\───────╮   ┃  │\n *\t│  ┃   ╭───────/ \\───────╮   ┃  │   │  ┃   │     Balloon     │   ┃  │\n *\t│  ┃   │     Balloon     │   ┃  │   │  ┃   ╰─────────────────╯   ┃  │\n *\t│  ┃   ╰─────────────────╯   ┃  │   │  ┃                         ┃  │\n *\t│  ┃                         ┃  │   │  ┃                         ┃  │\n *\t│  ┃                         ┃  │   │  ┃                         ┃  │\n *\t│  ┃                         ┃  │   │  ┃                         ┃  │\n *\t│  ┃                         ┃  │   │  ┃                         ┃  │\n *\t│  ┃                         ┃  │   │  ┃                         ┃  │\n *\t│  ┃                         ┃  │   │  ┃                         ┃  │\n *\t└──╀─────────────────────────╀──┘   └──╀─────────────────────────╀──┘\n *\t   ┊                         ┊         ┊                         ┊\n *\t   ┊                         ┊         └┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┘\n *\t   ┊                         ┊\n *\t   └┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┘\n *\n * **Note**: Works best if used together with\n * {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions default `BalloonPanelView` positions}\n * like `northArrowSouth` and `southArrowNorth`; the transition between these two and this position is smooth.\n *\n * @param {module:utils/dom/rect~Rect} widgetRect A rect of the widget.\n * @param {module:utils/dom/rect~Rect} balloonRect A rect of the balloon.\n * @returns {module:utils/dom/position~Position|null}\n */\nexport function centeredBalloonPositionForLongWidgets( widgetRect, balloonRect ) {\n\tconst viewportRect = new Rect( global.window );\n\tconst viewportWidgetInsersectionRect = viewportRect.getIntersection( widgetRect );\n\n\tconst balloonTotalHeight = balloonRect.height + BalloonPanelView.arrowVerticalOffset;\n\n\t// If there is enough space above or below the widget then this position should not be used.\n\tif ( widgetRect.top - balloonTotalHeight > viewportRect.top || widgetRect.bottom + balloonTotalHeight < viewportRect.bottom ) {\n\t\treturn null;\n\t}\n\n\t// Because this is a last resort positioning, to keep things simple we're not playing with positions of the arrow\n\t// like, for instance, \"south west\" or whatever. Just try to keep the balloon in the middle of the visible area of\n\t// the widget for as long as it is possible. If the widgets becomes invisible (because cropped by the viewport),\n\t// just... place the balloon in the middle of it (because why not?).\n\tconst targetRect = viewportWidgetInsersectionRect || widgetRect;\n\tconst left = targetRect.left + targetRect.width / 2 - balloonRect.width / 2;\n\n\treturn {\n\t\ttop: Math.max( widgetRect.top, 0 ) + BalloonPanelView.arrowVerticalOffset,\n\t\tleft,\n\t\tname: 'arrow_n'\n\t};\n}\n\n// Default filler offset function applied to all widget elements.\n//\n// @returns {null}\nfunction getFillerOffset() {\n\treturn null;\n}\n\n// Adds a drag handle to the widget.\n//\n// @param {module:engine/view/containerelement~ContainerElement}\n// @param {module:engine/view/downcastwriter~DowncastWriter} writer\nfunction addSelectionHandle( widgetElement, writer ) {\n\tconst selectionHandle = writer.createUIElement( 'div', { class: 'ck ck-widget__selection-handle' }, function( domDocument ) {\n\t\tconst domElement = this.toDomElement( domDocument );\n\n\t\t// Use the IconView from the ui library.\n\t\tconst icon = new IconView();\n\t\ticon.set( 'content', dragHandleIcon );\n\n\t\t// Render the icon view right away to append its #element to the selectionHandle DOM element.\n\t\ticon.render();\n\n\t\tdomElement.appendChild( icon.element );\n\n\t\treturn domElement;\n\t} );\n\n\t// Append the selection handle into the widget wrapper.\n\twriter.insert( writer.createPositionAt( widgetElement, 0 ), selectionHandle );\n\twriter.addClass( [ 'ck-widget_with-selection-handle' ], widgetElement );\n}\n"]},"metadata":{},"sourceType":"module"}